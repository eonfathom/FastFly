<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FlyWire Connectome Simulator</title>
<script>
// API Configuration
window.API_BASE_URL = 'http://127.0.0.1:8000';
window.WS_BASE_URL = 'ws://127.0.0.1:8000';
const originalFetch = window.fetch;
window.fetch = function(url, options) {
    if (typeof url === 'string' && url.startsWith('/api/')) {
        url = window.API_BASE_URL + url;
    }
    return originalFetch(url, options);
};
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #0a0e17;
    color: #e0e0e0;
    height: 100vh;
    overflow: hidden;
}
.layout {
    display: grid;
    grid-template-columns: 260px 1fr 320px;
    height: 100vh;
    gap: 0;
}
.panel {
    padding: 16px;
    overflow-y: auto;
}
.panel-left {
    background: #111827;
    border-right: 1px solid #1e293b;
}
.panel-center {
    background: #0a0e17;
    display: flex;
    flex-direction: column;
    padding: 0;
}
.panel-right {
    background: #111827;
    border-left: 1px solid #1e293b;
}
h1 {
    font-size: 15px;
    font-weight: 600;
    color: #60a5fa;
    margin-bottom: 16px;
    letter-spacing: 0.5px;
}
h2 {
    font-size: 12px;
    font-weight: 600;
    color: #94a3b8;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin: 16px 0 8px 0;
}
.btn-group {
    display: flex;
    gap: 6px;
    margin-bottom: 12px;
}
button {
    padding: 7px 14px;
    border: 1px solid #334155;
    background: #1e293b;
    color: #e2e8f0;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    transition: background 0.15s;
}
button:hover { background: #334155; }
button.active { background: #2563eb; border-color: #3b82f6; }
button.inject { background: #065f46; border-color: #10b981; }
button.inject:hover { background: #047857; }
button.clear { background: #7f1d1d; border-color: #ef4444; }
button.clear:hover { background: #991b1b; }
button.env-food { background: #4a2c0a; border-color: #d97706; font-size: 12px; }
button.env-food:hover { background: #5c3a10; }
button.env-food.active { background: #92400e; border-color: #f59e0b; }
button.env-obstacle { background: #1e293b; border-color: #64748b; font-size: 12px; }
button.env-obstacle:hover { background: #334155; }
button.env-obstacle.active { background: #334155; border-color: #94a3b8; }
label {
    display: block;
    font-size: 12px;
    color: #94a3b8;
    margin: 8px 0 4px 0;
}
select, input[type="number"], input[type="range"] {
    width: 100%;
    padding: 6px 8px;
    background: #0f172a;
    border: 1px solid #334155;
    color: #e2e8f0;
    border-radius: 4px;
    font-size: 13px;
}
input[type="range"] {
    padding: 0;
    margin: 4px 0;
}
.slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
}
.slider-row input[type="range"] { flex: 1; }
.slider-val {
    font-size: 12px;
    color: #60a5fa;
    min-width: 36px;
    text-align: right;
}
.metric-card {
    background: #1e293b;
    border-radius: 8px;
    padding: 8px 10px;
    margin-bottom: 6px;
}
.metric-row {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
}
.metric-label {
    font-size: 11px;
    color: #64748b;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.metric-value {
    font-size: 18px;
    font-weight: 700;
    color: #f1f5f9;
}
.metric-value.rate { color: #34d399; }
.metric-value.speed { color: #60a5fa; }
.metric-value.voltage { color: #fbbf24; }
.status-dot {
    display: inline-block;
    width: 8px; height: 8px;
    border-radius: 50%;
    margin-right: 6px;
}
.status-dot.connected { background: #34d399; }
.status-dot.disconnected { background: #ef4444; }
.status-dot.running { background: #34d399; animation: pulse 1s infinite; }
.status-dot.paused { background: #fbbf24; }
@keyframes pulse { 50% { opacity: 0.4; } }
#status-bar {
    font-size: 12px;
    color: #94a3b8;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
}

/* Scene container */
#scene-container {
    flex: 1;
    position: relative;
    min-height: 0;
    overflow: hidden;
}
#scene-container canvas {
    width: 100% !important;
    height: 100% !important;
    display: block;
}
#scene-info {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 11px;
    color: rgba(255,255,240,0.5);
    pointer-events: none;
    line-height: 1.5;
}
#brain-legend {
    position: absolute;
    bottom: 10px;
    left: 10px;
    font-size: 10px;
    color: #aab;
    pointer-events: none;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    background: rgba(0,0,0,0.4);
    padding: 4px 8px;
    border-radius: 4px;
}
.legend-item {
    display: flex;
    align-items: center;
    gap: 3px;
}
.legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}
#placement-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 12px;
    color: #fbbf24;
    background: rgba(0,0,0,0.6);
    padding: 6px 12px;
    border-radius: 6px;
    display: none;
    pointer-events: none;
}

/* Mini stimulus body map */
.stim-body-map {
    position: relative;
    width: 100%;
    margin: 4px 0;
}
.stim-body-map svg { width: 100%; }
.stim-zone {
    cursor: pointer;
    transition: opacity 0.15s;
}
.stim-zone:hover { opacity: 0.8; }
.stim-zone rect, .stim-zone ellipse, .stim-zone path {
    fill: #1e293b;
    stroke: #475569;
    stroke-width: 1;
    transition: fill 0.15s, stroke 0.15s;
}
.stim-zone:hover rect, .stim-zone:hover ellipse, .stim-zone:hover path {
    fill: #2d3a52;
    stroke: #60a5fa;
    stroke-width: 1.5;
}
.stim-zone.stim-active rect, .stim-zone.stim-active ellipse, .stim-zone.stim-active path {
    fill: #065f46;
    stroke: #34d399;
    stroke-width: 1.5;
    stroke-dasharray: 3 1.5;
}
.stim-zone-label {
    font-size: 7.5px;
    fill: #94a3b8;
    text-anchor: middle;
    pointer-events: none;
}
.stim-zone-icon {
    font-size: 11px;
    text-anchor: middle;
    pointer-events: none;
}

/* Motor readout */
.motor-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
    margin-top: 4px;
}
.motor-card {
    background: #1e293b;
    border-radius: 6px;
    padding: 6px 8px;
    text-align: center;
    border: 1px solid #1e293b;
    transition: border-color 0.3s, background 0.3s;
    cursor: pointer;
}
.motor-card:hover {
    border-color: #60a5fa;
    background: #1e2d4a;
}
.motor-card.active {
    border-color: #f97316;
}
.motor-name {
    font-size: 9px;
    color: #94a3b8;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.motor-rate {
    font-size: 14px;
    font-weight: 700;
    color: #f1f5f9;
    margin-top: 1px;
}
.motor-count {
    font-size: 8px;
    color: #64748b;
}
.motor-bar {
    height: 3px;
    background: #0f172a;
    border-radius: 2px;
    margin-top: 3px;
    overflow: hidden;
}
.motor-bar-fill {
    height: 100%;
    background: #f97316;
    border-radius: 2px;
    width: 0%;
    transition: width 0.3s, background 0.3s;
}
.motor-click-hint {
    font-size: 7px;
    color: #475569;
    margin-top: 2px;
}

/* Motor detail modal */
.modal-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}
.modal-overlay.visible { display: flex; }
.modal-box {
    background: #111827;
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 20px;
    max-width: 520px;
    width: 90%;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
}
.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
}
.modal-title {
    font-size: 16px;
    font-weight: 700;
    color: #60a5fa;
}
.modal-close {
    background: none;
    border: none;
    color: #94a3b8;
    font-size: 20px;
    cursor: pointer;
    padding: 4px 8px;
}
.modal-close:hover { color: #e2e8f0; background: none; }
.modal-subtitle {
    font-size: 12px;
    color: #64748b;
    margin-bottom: 12px;
}
.modal-subtitle .active-count { color: #f97316; font-weight: 700; }
.modal-subtitle .total-count { color: #94a3b8; }
.neuron-list {
    overflow-y: auto;
    flex: 1;
    max-height: 55vh;
}
.neuron-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
}
.neuron-table th {
    text-align: left;
    padding: 6px 8px;
    border-bottom: 1px solid #334155;
    color: #94a3b8;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    position: sticky;
    top: 0;
    background: #111827;
}
.neuron-table td {
    padding: 4px 8px;
    border-bottom: 1px solid #1e293b;
    color: #e2e8f0;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 11px;
}
.neuron-table tr.neuron-active td {
    color: #f97316;
    font-weight: 600;
}
.neuron-table tr.neuron-active td:first-child::before {
    content: '';
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #f97316;
    margin-right: 6px;
    animation: pulse 1s infinite;
}
.neuron-table tr:not(.neuron-active) td:first-child::before {
    content: '';
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #334155;
    margin-right: 6px;
}
</style>
</head>
<body>
<div class="layout">
    <!-- Left Panel: Controls -->
    <div class="panel panel-left">
        <h1>FlyWire Simulator</h1>
        <div style="margin-bottom: 12px; padding: 8px; background: #1e293b; border-radius: 4px;">
            <a href="/io-analysis" style="color: #60a5fa; text-decoration: none; font-size: 13px;">
                &rarr; I/O Analysis
            </a>
        </div>
        <div id="status-bar">
            <span class="status-dot disconnected" id="status-dot"></span>
            <span id="status-text">Connecting...</span>
        </div>

        <h2>Simulation</h2>
        <div class="btn-group">
            <button id="btn-play" onclick="sendCmd('start')">Play</button>
            <button id="btn-pause" onclick="sendCmd('pause')">Pause</button>
            <button id="btn-step" onclick="sendCmd('step')">Step</button>
        </div>

        <label>Simulation Speed</label>
        <div class="slider-row">
            <input type="range" id="speed-slider" min="-10" max="10" value="0" step="1"
                   oninput="updateSpeedSlider(this)">
            <span class="slider-val" id="speed-val">1.0x</span>
        </div>

        <label>Noise amplitude</label>
        <div class="slider-row">
            <input type="range" id="noise-amp" min="0" max="1.0" value="0.4" step="0.05"
                   oninput="updateSlider(this, 'noise-val'); sendParam('noise_amp', this.value)">
            <span class="slider-val" id="noise-val">0.40</span>
        </div>

        <h2>Data Toggles</h2>
        <div style="font-size:11px; line-height:2;">
            <label style="display:flex; align-items:center; gap:6px; margin:0; cursor:pointer;">
                <input type="checkbox" id="tog-3d" checked
                       onchange="sendParam('send_active_indices', this.checked ? 1 : 0)">
                3D brain data
            </label>
            <label style="display:flex; align-items:center; gap:6px; margin:0; cursor:pointer;">
                <input type="checkbox" id="tog-motor" checked
                       onchange="sendParam('send_motor_rates', this.checked ? 1 : 0)">
                Motor output data
            </label>
        </div>

        <h2>Stimulus &mdash; click to apply</h2>
        <div class="stim-body-map" id="stim-body-map"></div>

        <label>Amplitude</label>
        <div class="slider-row">
            <input type="range" id="stim-amp" min="0.1" max="5.0" value="0.5" step="0.1"
                   oninput="updateSlider(this, 'amp-val')">
            <span class="slider-val" id="amp-val">0.50</span>
        </div>

        <div class="btn-group" style="margin-top: 6px;">
            <button class="clear" onclick="clearStimulus()">Clear Stimulus</button>
        </div>

        <p id="stim-status" style="font-size:11px; color:#64748b; margin-top:4px;"></p>

        <details style="margin-top:8px;">
            <summary style="font-size:11px; color:#64748b; cursor:pointer;">Advanced: custom range</summary>
            <label>Start index</label>
            <input type="number" id="stim-start" value="0" min="0">
            <label>End index</label>
            <input type="number" id="stim-end" value="1000" min="0">
            <button class="inject" style="margin-top:6px;" onclick="injectCustomStimulus()">Inject Custom</button>
        </details>

        <h2>Environment</h2>
        <div class="btn-group">
            <button class="env-food" id="btn-add-food" onclick="togglePlacement('food')">+ Food</button>
            <button class="env-obstacle" id="btn-add-obstacle" onclick="togglePlacement('obstacle')">+ Obstacle</button>
            <button class="clear" onclick="clearEnvironment()" style="font-size:12px;">Clear All</button>
        </div>
        <p id="env-status" style="font-size:10px; color:#475569;"></p>

        <h2>Metrics</h2>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Step</span>
            <span class="metric-value" id="m-step">0</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Firing Rate</span>
            <span class="metric-value rate" id="m-rate">0%</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Spikes / batch</span>
            <span class="metric-value" id="m-spikes">0</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Mean V</span>
            <span class="metric-value voltage" id="m-voltage">0.000</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Steps/sec</span>
            <span class="metric-value speed" id="m-sps">0</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">vs Real-time</span>
            <span class="metric-value speed" id="m-realtime">0x</span>
        </div></div>
    </div>

    <!-- Center Panel: Unified 3D Scene -->
    <div class="panel panel-center">
        <div id="scene-container">
            <div id="scene-info">Loading 3D scene...</div>
            <div id="brain-legend"></div>
            <div id="placement-indicator">Click ground to place</div>
        </div>
    </div>

    <!-- Right Panel: Motor Output -->
    <div class="panel panel-right">
        <h2>Fly Status</h2>
        <p style="font-size:11px; color:#64748b; margin-bottom:8px;">
            Click fly in the 3D scene to stimulate. Orange glow = motor activity.
        </p>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Fly Speed</span>
            <span class="metric-value" id="m-flyspeed" style="font-size:14px;">0.00</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Heading</span>
            <span class="metric-value" id="m-flyheading" style="font-size:14px;">0&deg;</span>
        </div></div>

        <h2>Motor Output</h2>
        <p style="font-size:10px; color:#475569; margin-bottom:4px;">Click cards to see active neurons</p>
        <div class="motor-grid" id="motor-grid"></div>

        <h2 style="margin-top:12px;">Network</h2>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Neurons</span>
            <span class="metric-value" id="m-neurons" style="font-size:14px;">-</span>
        </div></div>
        <div class="metric-card"><div class="metric-row">
            <span class="metric-label">Synapses</span>
            <span class="metric-value" id="m-synapses" style="font-size:14px;">-</span>
        </div></div>
    </div>
</div>

<!-- Motor Detail Modal -->
<div class="modal-overlay" id="motor-modal">
    <div class="modal-box">
        <div class="modal-header">
            <span class="modal-title" id="modal-group-name">Motor Group</span>
            <button class="modal-close" onclick="closeMotorModal()">&times;</button>
        </div>
        <div class="modal-subtitle" id="modal-subtitle"></div>
        <div class="neuron-list">
            <table class="neuron-table">
                <thead>
                    <tr>
                        <th>Status</th>
                        <th>Neuron Index</th>
                        <th>Root ID</th>
                    </tr>
                </thead>
                <tbody id="modal-neuron-tbody"></tbody>
            </table>
        </div>
    </div>
</div>

<script>
// ========================================================================
// STATE
// ========================================================================
let ws = null;
let running = false;
let bodyInfo = null;
let activeStimulus = null;
let lastActiveIndices = [];
let lastMotorRates = null;

// Motor detail modal
let currentMotorDetailGroup = null;
let currentMotorDetailNeurons = null;
let motorDetailLastUpdate = 0;
const MOTOR_DETAIL_THROTTLE_MS = 300;

// 3D Scene
let scene, camera, renderer, controls;
let flyEntity;        // top-level group that moves/rotates
let flyBodyGroup;     // fly body model (child of flyEntity)
let brainGroup;       // brain point cloud (child of flyEntity)
let flyMeshMap = {};
let flyClickTargets = [];
let flyStimHighlights = [];
let groundMesh;

// Brain
let brainPoints = null;
let brainGlowPoints = null;
let brainPositions = null;
let brainBaseColors = null;
let brainGlowColors = null;
let brainClassLabels = null;
let brainN = 0;
const MAX_GLOW = 5000;
const GLOW_COLOR = [0.2, 0.85, 1.0];
const DIM_ALPHA = 0.5;

const CLASS_COLORS = [
    [0.85, 0.25, 0.55],
    [0.10, 0.70, 0.95],
    [0.75, 0.18, 0.70],
    [0.60, 0.15, 0.50],
    [0.20, 0.55, 0.90],
    [0.90, 0.35, 0.65],
    [0.15, 0.80, 0.85],
    [0.70, 0.20, 0.60],
    [0.30, 0.65, 0.95],
    [0.95, 0.40, 0.70],
];

// Fly movement
let flyPos = { x: 0, z: 0 };
let flyAngle = 0;
let flySpeed = 0;
let gaitPhase = 0;
let speedMultiplier = 1.0;
const BASE_BATCH = 50;

// Leg animation
let legAnimA = []; // FL, MR, HL
let legAnimB = []; // FR, ML, HR

// Environment objects
let envObjects = [];
let placementMode = null;

// Animation
let lastFrameTime = 0;
const GARDEN_SIZE = 8;
const GROUND_Y = -0.9;

// ========================================================================
// TEXTURES
// ========================================================================
function createRakedSandTexture() {
    var size = 1024;
    var canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext('2d');

    // Base warm sand
    ctx.fillStyle = '#e8dcc8';
    ctx.fillRect(0, 0, size, size);

    // Subtle grain noise
    var imgData = ctx.getImageData(0, 0, size, size);
    for (var i = 0; i < imgData.data.length; i += 4) {
        var n = (Math.random() - 0.5) * 12;
        imgData.data[i] += n;
        imgData.data[i + 1] += n;
        imgData.data[i + 2] += n;
    }
    ctx.putImageData(imgData, 0, 0);

    // Concentric raked circles (off-center for wabi-sabi)
    var cx = size * 0.35, cy = size * 0.42;
    ctx.strokeStyle = 'rgba(180, 165, 140, 0.4)';
    ctx.lineWidth = 1.5;
    for (var r = 25; r < size * 0.85; r += 9) {
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Secondary center
    var cx2 = size * 0.72, cy2 = size * 0.6;
    for (var r = 20; r < size * 0.35; r += 9) {
        ctx.beginPath();
        ctx.arc(cx2, cy2, r, 0, Math.PI * 2);
        ctx.stroke();
    }

    var tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    return tex;
}

function createSkyGradient() {
    var canvas = document.createElement('canvas');
    canvas.width = 4;
    canvas.height = 512;
    var ctx = canvas.getContext('2d');
    var grad = ctx.createLinearGradient(0, 0, 0, 512);
    grad.addColorStop(0, '#b0a0cc');   // lavender above
    grad.addColorStop(0.4, '#c8b4a0'); // warm mid
    grad.addColorStop(0.7, '#e0c89a'); // amber horizon
    grad.addColorStop(1, '#d4a574');   // deeper amber below
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 4, 512);
    var tex = new THREE.CanvasTexture(canvas);
    return tex;
}

function createWoodTexture() {
    var canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = '#8b6914';
    ctx.fillRect(0, 0, 256, 256);
    ctx.strokeStyle = 'rgba(100, 70, 20, 0.3)';
    ctx.lineWidth = 1;
    for (var y = 0; y < 256; y += 3 + Math.random() * 4) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        for (var x = 0; x < 256; x += 10) {
            ctx.lineTo(x, y + (Math.random() - 0.5) * 2);
        }
        ctx.stroke();
    }
    return new THREE.CanvasTexture(canvas);
}

function createMossTexture() {
    var canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = '#2d5a1e';
    ctx.fillRect(0, 0, 128, 128);
    for (var i = 0; i < 200; i++) {
        var x = Math.random() * 128;
        var y = Math.random() * 128;
        var r = 1 + Math.random() * 3;
        var g = 80 + Math.random() * 80;
        ctx.fillStyle = 'rgb(' + Math.floor(20 + Math.random() * 40) + ',' + Math.floor(g) + ',' + Math.floor(10 + Math.random() * 30) + ')';
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }
    return new THREE.CanvasTexture(canvas);
}

// ========================================================================
// SCENE INITIALIZATION
// ========================================================================
function initScene() {
    var container = document.getElementById('scene-container');
    var w = container.clientWidth;
    var h = container.clientHeight;

    scene = new THREE.Scene();
    scene.background = createSkyGradient();
    scene.fog = new THREE.FogExp2(0xe0c89a, 0.025);

    camera = new THREE.PerspectiveCamera(50, w / h, 0.01, 200);
    camera.position.set(0, 6, -10);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.rotateSpeed = 0.8;
    controls.target.set(0, 0, 0);
    controls.maxPolarAngle = Math.PI * 0.48;
    controls.minDistance = 3;
    controls.maxDistance = 40;

    // Lighting — warm late-afternoon
    var ambient = new THREE.AmbientLight(0xffeedd, 0.45);
    scene.add(ambient);

    var sun = new THREE.DirectionalLight(0xffddaa, 1.0);
    sun.position.set(6, 10, -4);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 1024;
    sun.shadow.mapSize.height = 1024;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 40;
    sun.shadow.camera.left = -15;
    sun.shadow.camera.right = 15;
    sun.shadow.camera.top = 15;
    sun.shadow.camera.bottom = -15;
    scene.add(sun);

    var fill = new THREE.DirectionalLight(0x8899bb, 0.25);
    fill.position.set(-4, 4, 6);
    scene.add(fill);

    buildZenGarden();
    buildFlyEntity();
    loadBrain();

    // Click handler
    renderer.domElement.addEventListener('click', onSceneClick);
    renderer.domElement.addEventListener('dblclick', resetCamera);

    // Resize
    new ResizeObserver(onResize).observe(container);

    document.getElementById('scene-info').innerHTML =
        'Drag to rotate | Scroll to zoom | Double-click to reset camera';

    startAnimation();
}

// ========================================================================
// ZEN GARDEN ENVIRONMENT
// ========================================================================
function buildZenGarden() {
    var gs = GARDEN_SIZE;

    // Ground plane — raked sand
    var sandTex = createRakedSandTexture();
    var groundGeom = new THREE.PlaneGeometry(gs * 2 + 1, gs * 2 + 1);
    var groundMat = new THREE.MeshPhongMaterial({
        map: sandTex,
        color: 0xffffff,
        shininess: 5,
    });
    groundMesh = new THREE.Mesh(groundGeom, groundMat);
    groundMesh.rotation.x = -Math.PI / 2;
    groundMesh.position.y = GROUND_Y;
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    // Wooden border
    var woodTex = createWoodTexture();
    var borderMat = new THREE.MeshPhongMaterial({ map: woodTex, color: 0xffffff, shininess: 10 });
    var bt = 0.3, bh = 0.4;

    var nb = new THREE.Mesh(new THREE.BoxGeometry(gs * 2 + bt * 2 + 1, bh, bt), borderMat);
    nb.position.set(0, GROUND_Y + bh / 2, gs + 0.5 + bt / 2);
    nb.castShadow = true;
    scene.add(nb);

    var sb = new THREE.Mesh(new THREE.BoxGeometry(gs * 2 + bt * 2 + 1, bh, bt), borderMat);
    sb.position.set(0, GROUND_Y + bh / 2, -(gs + 0.5 + bt / 2));
    sb.castShadow = true;
    scene.add(sb);

    var eb = new THREE.Mesh(new THREE.BoxGeometry(bt, bh, gs * 2 + 1), borderMat);
    eb.position.set(gs + 0.5 + bt / 2, GROUND_Y + bh / 2, 0);
    eb.castShadow = true;
    scene.add(eb);

    var wb = new THREE.Mesh(new THREE.BoxGeometry(bt, bh, gs * 2 + 1), borderMat);
    wb.position.set(-(gs + 0.5 + bt / 2), GROUND_Y + bh / 2, 0);
    wb.castShadow = true;
    scene.add(wb);

    // Basalt stones — asymmetric cluster
    var stoneDefs = [
        { pos: [5, GROUND_Y + 0.25, 5], scl: [0.9, 0.5, 0.75], color: 0x2a2a32 },
        { pos: [5.9, GROUND_Y + 0.15, 4.1], scl: [0.55, 0.35, 0.45], color: 0x28282e },
        { pos: [4.4, GROUND_Y + 0.12, 5.6], scl: [0.4, 0.28, 0.38], color: 0x2c2c34 },
    ];
    stoneDefs.forEach(function(s) {
        var geom = new THREE.SphereGeometry(1, 14, 10);
        var mat = new THREE.MeshPhongMaterial({
            color: s.color,
            shininess: 50,
            specular: 0x444444,
        });
        var mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(s.pos[0], s.pos[1], s.pos[2]);
        mesh.scale.set(s.scl[0], s.scl[1], s.scl[2]);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
    });

    // Moss patch near stones
    var mossGeom = new THREE.PlaneGeometry(1.8, 1.5);
    var mossTex = createMossTexture();
    var mossMat = new THREE.MeshPhongMaterial({
        map: mossTex,
        transparent: true,
        opacity: 0.85,
    });
    var moss = new THREE.Mesh(mossGeom, mossMat);
    moss.rotation.x = -Math.PI / 2;
    moss.position.set(5.2, GROUND_Y + 0.01, 6.2);
    scene.add(moss);

    // Cherry blossom branch
    var branchCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-7, 3.5, 7),
        new THREE.Vector3(-5, 4.2, 5),
        new THREE.Vector3(-3.5, 3.8, 3),
        new THREE.Vector3(-2.5, 3.2, 1.5),
    ]);
    var branchGeom = new THREE.TubeGeometry(branchCurve, 20, 0.07, 6, false);
    var branchMat = new THREE.MeshPhongMaterial({ color: 0x5c3a1e, shininess: 15 });
    var branch = new THREE.Mesh(branchGeom, branchMat);
    branch.castShadow = true;
    scene.add(branch);

    // Sub-branch
    var subCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-4, 4.0, 4),
        new THREE.Vector3(-3.2, 4.5, 3.5),
        new THREE.Vector3(-2.8, 4.3, 2.5),
    ]);
    var subGeom = new THREE.TubeGeometry(subCurve, 12, 0.035, 5, false);
    scene.add(new THREE.Mesh(subGeom, branchMat));

    // Blossoms on branch
    var blossomMat = new THREE.MeshPhongMaterial({ color: 0xf8c8d8, shininess: 20 });
    for (var t = 0.2; t < 0.95; t += 0.12) {
        var pt = branchCurve.getPointAt(t);
        for (var j = 0; j < 3; j++) {
            var blossom = new THREE.Mesh(
                new THREE.SphereGeometry(0.06 + Math.random() * 0.04, 6, 4),
                blossomMat
            );
            blossom.position.set(
                pt.x + (Math.random() - 0.5) * 0.35,
                pt.y + Math.random() * 0.25,
                pt.z + (Math.random() - 0.5) * 0.35
            );
            scene.add(blossom);
        }
    }

    // Fallen petals on sand
    var petalGeom = new THREE.CircleGeometry(0.12, 5);
    var petalMat = new THREE.MeshPhongMaterial({
        color: 0xf5b7c5,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.75,
    });
    for (var i = 0; i < 18; i++) {
        var petal = new THREE.Mesh(petalGeom, petalMat.clone());
        petal.position.set(
            -6 + Math.random() * 7,
            GROUND_Y + 0.01,
            1 + Math.random() * 7
        );
        petal.rotation.set(-Math.PI / 2 + (Math.random() - 0.5) * 0.3, 0, Math.random() * Math.PI * 2);
        petal.scale.setScalar(0.5 + Math.random() * 0.6);
        scene.add(petal);
    }

    // Shoji screen suggestion (backlit plane in background)
    var shojiGeom = new THREE.PlaneGeometry(22, 8);
    var shojiMat = new THREE.MeshBasicMaterial({
        color: 0xfff5e6,
        transparent: true,
        opacity: 0.08,
        side: THREE.DoubleSide,
    });
    var shoji = new THREE.Mesh(shojiGeom, shojiMat);
    shoji.position.set(0, 2.5, gs + 3);
    scene.add(shoji);

    // Grid lines on shoji
    for (var gx = -4; gx <= 4; gx += 2) {
        var lineGeom = new THREE.PlaneGeometry(0.04, 7.5);
        var lineMat = new THREE.MeshBasicMaterial({ color: 0xd4c4a0, transparent: true, opacity: 0.06 });
        var line = new THREE.Mesh(lineGeom, lineMat);
        line.position.set(gx * 1.2, 2.5, gs + 2.99);
        scene.add(line);
    }
}

// ========================================================================
// FLY ENTITY (GLB Model from TuragaLab/flybody)
// ========================================================================
var flyHeadCenter = null;
var flyHeadSize = null;

function buildFlyEntity() {
    flyEntity = new THREE.Group();
    flyEntity.position.set(0, 0, 0);
    scene.add(flyEntity);

    flyBodyGroup = new THREE.Group();
    flyEntity.add(flyBodyGroup);

    flyMeshMap = {};
    flyClickTargets = [];
    flyStimHighlights = [];

    // Brain group — will be positioned after head mesh loads
    brainGroup = new THREE.Group();
    flyEntity.add(brainGroup);

    loadFlyModel();
}

function loadFlyModel() {
    var loader = new THREE.GLTFLoader();
    loader.load('/static/models/flybody.glb', function(gltf) {
        var model = gltf.scene;

        // Stimulus mapping by body name
        var bodyStimMap = {
            'antenna_left': 'Tickle (left antenna)',
            'antenna_right': 'Tickle (right antenna)',
            'rostrum': 'Sugar (proboscis)',
            'haustellum': 'Sugar (proboscis)',
            'labrum_left': 'Sugar (left proboscis)',
            'labrum_right': 'Sugar (right proboscis)',
        };

        model.traverse(function(child) {
            if (!child.isMesh) return;

            var nodeName = child.name;
            var parts = nodeName.split('__');
            var bodyName = parts[0] || nodeName;
            var meshName = parts[1] || nodeName;

            // Determine opacity by body region
            var opacity = 0.35;
            if (bodyName === 'head' || bodyName === 'thorax') opacity = 0.25;
            else if (bodyName.indexOf('abdomen') === 0) opacity = 0.25;
            else if (bodyName.indexOf('wing') === 0) opacity = 0.18;
            else if (bodyName.indexOf('haltere') === 0) opacity = 0.5;
            else if (bodyName.indexOf('antenna') === 0) opacity = 0.6;
            else if (bodyName === 'rostrum' || bodyName === 'haustellum') opacity = 0.6;
            else if (bodyName.indexOf('labrum') === 0) opacity = 0.6;
            else if (bodyName.match(/coxa|femur|tibia|tarsus|claw/)) opacity = 0.55;

            // Special overrides by mesh name
            if (meshName === 'head_red') opacity = 0.45;
            if (meshName.indexOf('membrane') !== -1) opacity = 0.18;

            // Check for vertex colors from GLB
            var hasVertexColors = child.geometry && child.geometry.attributes &&
                                  child.geometry.attributes.color;

            // Replace material with transparent Phong
            child.material = new THREE.MeshPhongMaterial({
                vertexColors: hasVertexColors,
                color: hasVertexColors ? 0xffffff : 0x8c5924,
                emissive: 0x000000,
                shininess: 30,
                transparent: true,
                opacity: opacity,
                side: THREE.DoubleSide,
                depthWrite: false,
                flatShading: false,
            });
            child.castShadow = true;

            // Store in mesh map
            flyMeshMap[nodeName] = child;

            // Determine stimulus name
            var stimName = null;
            if (bodyStimMap[bodyName] !== undefined) {
                stimName = bodyStimMap[bodyName];
            } else if (meshName === 'head_red') {
                stimName = 'Light (left eye)';
            } else if (bodyName.match(/_left/) && bodyName.match(/coxa|femur|tibia|tarsus|claw/)) {
                stimName = 'Touch (left leg/body)';
            } else if (bodyName.match(/_right/) && bodyName.match(/coxa|femur|tibia|tarsus|claw/)) {
                stimName = 'Touch (right leg/body)';
            } else if (bodyName === 'wing_left') {
                stimName = 'Touch (left leg/body)';
            } else if (bodyName === 'wing_right') {
                stimName = 'Touch (right leg/body)';
            }

            child.userData.stimName = stimName;
            if (stimName) flyClickTargets.push(child);
        });

        flyBodyGroup.add(model);

        // Compute head bounding box for brain positioning
        computeHeadBounds();

        // Setup leg animation groups
        setupLegAnimation();

        // Reposition brain if it already loaded before the model
        if (brainPoints) repositionBrainInHead();

        console.log('Flybody model loaded: ' + Object.keys(flyMeshMap).length + ' meshes');
    }, undefined, function(error) {
        console.error('Failed to load flybody GLB:', error);
    });
}

function computeHeadBounds() {
    var box = new THREE.Box3();
    var found = false;
    for (var key in flyMeshMap) {
        if (key.startsWith('head__')) {
            var meshBox = new THREE.Box3().setFromObject(flyMeshMap[key]);
            box.union(meshBox);
            found = true;
        }
    }
    if (found) {
        flyHeadCenter = new THREE.Vector3();
        box.getCenter(flyHeadCenter);
        flyHeadSize = new THREE.Vector3();
        box.getSize(flyHeadSize);
    } else {
        flyHeadCenter = new THREE.Vector3(0, -0.2, 0.65);
        flyHeadSize = new THREE.Vector3(0.8, 0.5, 0.5);
    }
}

function repositionBrainInHead() {
    if (!flyHeadCenter || !flyHeadSize || !brainPositions) return;

    var bMin = [Infinity, Infinity, Infinity];
    var bMax = [-Infinity, -Infinity, -Infinity];
    for (var i = 0; i < brainPositions.length; i += 3) {
        for (var j = 0; j < 3; j++) {
            bMin[j] = Math.min(bMin[j], brainPositions[i + j]);
            bMax[j] = Math.max(bMax[j], brainPositions[i + j]);
        }
    }
    var bSize = [bMax[0] - bMin[0], bMax[1] - bMin[1], bMax[2] - bMin[2]];
    var bCenter = [(bMin[0] + bMax[0]) / 2, (bMin[1] + bMax[1]) / 2, (bMin[2] + bMax[2]) / 2];

    // Scale brain to fit inside head (85% of head dimensions)
    var headTarget = [flyHeadSize.x * 0.85, flyHeadSize.y * 0.85, flyHeadSize.z * 0.85];
    var sX = bSize[0] > 0 ? headTarget[0] / bSize[0] : 0.3;
    var sY = bSize[1] > 0 ? headTarget[1] / bSize[1] : 0.3;
    var sZ = bSize[2] > 0 ? headTarget[2] / bSize[2] : 0.3;

    brainGroup.scale.set(sX, sY, sZ);
    brainGroup.position.set(
        flyHeadCenter.x - bCenter[0] * sX,
        flyHeadCenter.y - bCenter[1] * sY,
        flyHeadCenter.z - bCenter[2] * sZ
    );
}

function setupLegAnimation() {
    legAnimA = [];
    legAnimB = [];
    // Tripod A: front-left (T1_left), mid-right (T2_right), hind-left (T3_left)
    // Tripod B: front-right (T1_right), mid-left (T2_left), hind-right (T3_right)
    var groupA = ['T1_left', 'T2_right', 'T3_left'];
    var groupB = ['T1_right', 'T2_left', 'T3_right'];

    for (var key in flyMeshMap) {
        var bodyName = key.split('__')[0];
        if (!bodyName.match(/coxa|femur|tibia|tarsus|claw/)) continue;

        var mesh = flyMeshMap[key];
        if (mesh.userData.baseY === undefined) mesh.userData.baseY = mesh.position.y;

        var isA = groupA.some(function(g) { return bodyName.indexOf(g) !== -1; });
        var isB = groupB.some(function(g) { return bodyName.indexOf(g) !== -1; });
        if (isA) legAnimA.push(mesh);
        else if (isB) legAnimB.push(mesh);
    }
}

// ========================================================================
// BRAIN POINT CLOUD
// ========================================================================
function loadBrain() {
    fetch('/api/positions')
        .then(function(r) { return r.json(); })
        .then(function(data) {
            brainN = data.n_neurons;

            // Decode positions
            if (data.positions_b64) {
                var raw = atob(data.positions_b64);
                var buf = new ArrayBuffer(raw.length);
                var view = new Uint8Array(buf);
                for (var i = 0; i < raw.length; i++) view[i] = raw.charCodeAt(i);
                brainPositions = new Float32Array(buf);

                // Normalize (same as before)
                var mnX = Infinity, mxX = -Infinity;
                var mnY = Infinity, mxY = -Infinity;
                var mnZ = Infinity, mxZ = -Infinity;
                for (var i = 0; i < brainPositions.length; i += 3) {
                    var x = brainPositions[i], y = brainPositions[i + 1], z = brainPositions[i + 2];
                    if (x < mnX) mnX = x; if (x > mxX) mxX = x;
                    if (y < mnY) mnY = y; if (y > mxY) mxY = y;
                    if (z < mnZ) mnZ = z; if (z > mxZ) mxZ = z;
                }
                var cX = (mnX + mxX) / 2, cY = (mnY + mxY) / 2, cZ = (mnZ + mxZ) / 2;
                var rangeX = (mxX - mnX) / 2 || 1;
                var rangeY = (mxY - mnY) / 2 || 1;
                var rangeZ = (mxZ - mnZ) / 2 || 1;
                var uniformScale = Math.max(rangeX, rangeY, rangeZ);
                var Z_STRETCH = 10.0;
                for (var i = 0; i < brainPositions.length; i += 3) {
                    brainPositions[i] = -((brainPositions[i] - cX) / uniformScale);
                    brainPositions[i + 1] = (brainPositions[i + 1] - cY) / uniformScale;
                    brainPositions[i + 2] = (brainPositions[i + 2] - cZ) / uniformScale * Z_STRETCH;
                }
            } else {
                brainPositions = new Float32Array(brainN * 3);
                for (var i = 0; i < brainN * 3; i++) brainPositions[i] = (Math.random() - 0.5) * 2;
            }

            // Position brain inside head (dynamic — uses GLB head bounds if loaded)
            repositionBrainInHead();

            // Class colors
            brainBaseColors = new Float32Array(brainN * 3);
            if (data.classes && data.classes.ids_b64) {
                brainClassLabels = data.classes.labels;
                var rawIds = atob(data.classes.ids_b64);
                var classIds = new Uint8Array(rawIds.length);
                for (var i = 0; i < rawIds.length; i++) classIds[i] = rawIds.charCodeAt(i);

                for (var i = 0; i < brainN; i++) {
                    var cid = classIds[i] || 0;
                    var c = CLASS_COLORS[cid % CLASS_COLORS.length];
                    brainBaseColors[i * 3] = c[0] * DIM_ALPHA;
                    brainBaseColors[i * 3 + 1] = c[1] * DIM_ALPHA;
                    brainBaseColors[i * 3 + 2] = c[2] * DIM_ALPHA;
                }
                buildBrainLegend(brainClassLabels);
            } else {
                for (var i = 0; i < brainN * 3; i++) brainBaseColors[i] = 0.15;
            }

            // Base layer (rendered opaque for correct transparency ordering)
            var baseGeom = new THREE.BufferGeometry();
            baseGeom.setAttribute('position', new THREE.BufferAttribute(brainPositions, 3));
            baseGeom.setAttribute('color', new THREE.BufferAttribute(brainBaseColors, 3));
            var baseMat = new THREE.PointsMaterial({
                size: 0.007,
                vertexColors: true,
                transparent: false,
                depthWrite: true,
                sizeAttenuation: true,
            });
            brainPoints = new THREE.Points(baseGeom, baseMat);
            brainPoints.renderOrder = 0;
            brainGroup.add(brainPoints);

            // Glow layer (active neurons)
            var glowPos = new Float32Array(MAX_GLOW * 3);
            brainGlowColors = new Float32Array(MAX_GLOW * 3);
            var glowGeom = new THREE.BufferGeometry();
            glowGeom.setAttribute('position', new THREE.BufferAttribute(glowPos, 3));
            glowGeom.setAttribute('color', new THREE.BufferAttribute(brainGlowColors, 3));
            glowGeom.setDrawRange(0, 0);
            var glowMat = new THREE.PointsMaterial({
                size: 0.022,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
            });
            brainGlowPoints = new THREE.Points(glowGeom, glowMat);
            brainGlowPoints.renderOrder = 1;
            brainGroup.add(brainGlowPoints);
        })
        .catch(function(err) {
            console.warn('Failed to load brain positions:', err);
        });
}

function updateBrainActivity(activeIndices) {
    if (!brainGlowPoints || !brainPositions) return;

    var glowPosAttr = brainGlowPoints.geometry.attributes.position;
    var glowColAttr = brainGlowPoints.geometry.attributes.color;
    var glowPos = glowPosAttr.array;
    var glowCol = glowColAttr.array;

    var count = 0;
    if (activeIndices && activeIndices.length > 0) {
        var limit = Math.min(activeIndices.length, MAX_GLOW);
        for (var j = 0; j < limit; j++) {
            var idx = activeIndices[j];
            if (idx >= 0 && idx < brainN) {
                glowPos[count * 3] = brainPositions[idx * 3];
                glowPos[count * 3 + 1] = brainPositions[idx * 3 + 1];
                glowPos[count * 3 + 2] = brainPositions[idx * 3 + 2];
                glowCol[count * 3] = GLOW_COLOR[0];
                glowCol[count * 3 + 1] = GLOW_COLOR[1];
                glowCol[count * 3 + 2] = GLOW_COLOR[2];
                count++;
            }
        }
    }

    brainGlowPoints.geometry.setDrawRange(0, count);
    glowPosAttr.needsUpdate = true;
    glowColAttr.needsUpdate = true;
}

function buildBrainLegend(labels) {
    var container = document.getElementById('brain-legend');
    container.innerHTML = '';
    labels.forEach(function(label, i) {
        var c = CLASS_COLORS[i % CLASS_COLORS.length];
        var item = document.createElement('span');
        item.className = 'legend-item';
        var dot = document.createElement('span');
        dot.className = 'legend-dot';
        dot.style.backgroundColor = 'rgb(' + Math.round(c[0] * 255) + ',' + Math.round(c[1] * 255) + ',' + Math.round(c[2] * 255) + ')';
        item.appendChild(dot);
        item.appendChild(document.createTextNode(label));
        container.appendChild(item);
    });
}

// ========================================================================
// FLY MOVEMENT
// ========================================================================
function updateFlyMovement(dt) {
    if (!lastMotorRates || !flyEntity) return;

    var left = lastMotorRates.descending_left || 0;
    var right = lastMotorRates.descending_right || 0;

    var forwardRate = (left + right) / 2;
    var turnRate = (left - right);

    // Only move when motor neurons fire
    if (forwardRate < 0.001 && Math.abs(turnRate) < 0.001) {
        flySpeed = 0;
        return;
    }

    var moveScale = 80 * speedMultiplier;
    var turnScale = 30;

    flySpeed = forwardRate * moveScale;
    flyAngle += turnRate * turnScale * dt;

    flyPos.x += Math.sin(flyAngle) * flySpeed * dt;
    flyPos.z += Math.cos(flyAngle) * flySpeed * dt;

    // Clamp to garden bounds
    var bound = GARDEN_SIZE - 0.5;
    flyPos.x = Math.max(-bound, Math.min(bound, flyPos.x));
    flyPos.z = Math.max(-bound, Math.min(bound, flyPos.z));

    flyEntity.position.x = flyPos.x;
    flyEntity.position.z = flyPos.z;
    flyEntity.rotation.y = flyAngle;

    // Update right panel
    var speedEl = document.getElementById('m-flyspeed');
    var headEl = document.getElementById('m-flyheading');
    if (speedEl) speedEl.textContent = flySpeed.toFixed(2);
    if (headEl) headEl.textContent = Math.round((flyAngle * 180 / Math.PI) % 360) + '\u00B0';
}

function animateLegs(dt) {
    if (flySpeed < 0.01) {
        // Reset to base positions when stationary
        legAnimA.concat(legAnimB).forEach(function(m) {
            if (m.userData.baseY !== undefined) m.position.y = m.userData.baseY;
        });
        return;
    }

    gaitPhase += flySpeed * dt * 12;

    var liftA = Math.max(0, Math.sin(gaitPhase)) * 0.07;
    var liftB = Math.max(0, Math.sin(gaitPhase + Math.PI)) * 0.07;

    legAnimA.forEach(function(m) {
        m.position.y = (m.userData.baseY || 0) + liftA;
    });
    legAnimB.forEach(function(m) {
        m.position.y = (m.userData.baseY || 0) + liftB;
    });
}

// ========================================================================
// ENVIRONMENT OBJECTS (Food & Obstacles)
// ========================================================================
function togglePlacement(mode) {
    var indicator = document.getElementById('placement-indicator');
    if (placementMode === mode) {
        placementMode = null;
        indicator.style.display = 'none';
        document.getElementById('btn-add-food').classList.remove('active');
        document.getElementById('btn-add-obstacle').classList.remove('active');
    } else {
        placementMode = mode;
        indicator.style.display = 'block';
        indicator.textContent = mode === 'food' ? 'Click ground to place food' : 'Click ground to place obstacle';
        document.getElementById('btn-add-food').classList.toggle('active', mode === 'food');
        document.getElementById('btn-add-obstacle').classList.toggle('active', mode === 'obstacle');
    }
}

function addFood(pos) {
    // Berry-like sphere
    var geom = new THREE.SphereGeometry(0.25, 10, 8);
    var mat = new THREE.MeshPhongMaterial({
        color: 0xcc5544,
        shininess: 30,
        emissive: 0x220808,
    });
    var mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(pos.x, GROUND_Y + 0.2, pos.z);
    mesh.castShadow = true;
    scene.add(mesh);
    envObjects.push({ mesh: mesh, type: 'food', radius: 0.25, x: pos.x, z: pos.z });
    updateEnvStatus();
}

function addObstacle(pos) {
    // Stone-like shape
    var geom = new THREE.SphereGeometry(0.5, 10, 8);
    var mat = new THREE.MeshPhongMaterial({
        color: 0x3a3a42,
        shininess: 40,
        specular: 0x333333,
    });
    var mesh = new THREE.Mesh(geom, mat);
    mesh.position.set(pos.x, GROUND_Y + 0.25, pos.z);
    mesh.scale.set(1, 0.6, 0.85);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    envObjects.push({ mesh: mesh, type: 'obstacle', radius: 0.5, x: pos.x, z: pos.z });
    updateEnvStatus();
}

function clearEnvironment() {
    envObjects.forEach(function(obj) {
        scene.remove(obj.mesh);
        if (obj.mesh.geometry) obj.mesh.geometry.dispose();
        if (obj.mesh.material) obj.mesh.material.dispose();
    });
    envObjects = [];
    updateEnvStatus();
}

function updateEnvStatus() {
    var food = envObjects.filter(function(o) { return o.type === 'food'; }).length;
    var obs = envObjects.filter(function(o) { return o.type === 'obstacle'; }).length;
    document.getElementById('env-status').textContent =
        food + ' food, ' + obs + ' obstacles placed';
}

function updateEnvironment(dt) {
    var attractRange = 5;
    var contactRange = 0.6;
    var obstacleRange = 1.0;

    for (var i = envObjects.length - 1; i >= 0; i--) {
        var obj = envObjects[i];
        var dx = obj.x - flyPos.x;
        var dz = obj.z - flyPos.z;
        var dist = Math.sqrt(dx * dx + dz * dz);

        if (obj.type === 'food') {
            // Attract fly heading toward food when within range
            if (dist < attractRange && dist > contactRange && flySpeed > 0.01) {
                var angleToFood = Math.atan2(dx, dz);
                var angleDiff = angleToFood - flyAngle;
                // Normalize to [-PI, PI]
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                flyAngle += angleDiff * 1.5 * dt;
                flyEntity.rotation.y = flyAngle;
            }

            // Eat food on contact
            if (dist < contactRange) {
                // Trigger gustatory stimulus
                if (ws && ws.readyState === 1) {
                    ws.send(JSON.stringify({ cmd: 'stimulus_preset', name: 'Sugar (proboscis)', amplitude: 1.0 }));
                }
                scene.remove(obj.mesh);
                obj.mesh.geometry.dispose();
                obj.mesh.material.dispose();
                envObjects.splice(i, 1);
                updateEnvStatus();
            }
        } else if (obj.type === 'obstacle') {
            // Push fly out on collision
            if (dist < obstacleRange && dist > 0.01) {
                var pushX = -dx / dist;
                var pushZ = -dz / dist;
                var overlap = obstacleRange - dist;
                flyPos.x += pushX * overlap * 1.1;
                flyPos.z += pushZ * overlap * 1.1;
                flyEntity.position.x = flyPos.x;
                flyEntity.position.z = flyPos.z;
            }
        }
    }
}

// ========================================================================
// CAMERA
// ========================================================================
function updateCamera(dt) {
    if (!controls) return;
    var targetPos = new THREE.Vector3(flyPos.x, 0, flyPos.z);
    controls.target.lerp(targetPos, 2.0 * dt);
}

function resetCamera() {
    if (!camera || !controls) return;
    camera.position.set(flyPos.x, 6, flyPos.z - 10);
    controls.target.set(flyPos.x, 0, flyPos.z);
}

// ========================================================================
// ANIMATION LOOP
// ========================================================================
function startAnimation() {
    lastFrameTime = performance.now();
    animate(lastFrameTime);
}

function animate(time) {
    requestAnimationFrame(animate);

    var dt = Math.min((time - lastFrameTime) / 1000, 0.05);
    lastFrameTime = time;

    updateFlyMovement(dt);
    animateLegs(dt);
    updateEnvironment(dt);
    updateCamera(dt);

    if (controls) controls.update();
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
}

function onResize() {
    var container = document.getElementById('scene-container');
    if (!container || !renderer || !camera) return;
    var w = container.clientWidth;
    var h = container.clientHeight;
    if (w > 0 && h > 0) {
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
    }
}

// ========================================================================
// CLICK HANDLING
// ========================================================================
function onSceneClick(event) {
    var container = document.getElementById('scene-container');
    var rect = renderer.domElement.getBoundingClientRect();
    var mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
    );

    var raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    // Placement mode — place on ground
    if (placementMode && groundMesh) {
        var groundHits = raycaster.intersectObject(groundMesh);
        if (groundHits.length > 0) {
            var pt = groundHits[0].point;
            if (placementMode === 'food') {
                addFood({ x: pt.x, z: pt.z });
            } else {
                addObstacle({ x: pt.x, z: pt.z });
            }
            togglePlacement(placementMode); // exit placement mode
            return;
        }
    }

    // Click fly body to stimulate
    var hits = raycaster.intersectObjects(flyClickTargets, false);
    if (hits.length > 0) {
        var stimName = hits[0].object.userData.stimName;
        if (stimName) stimulateBodyPart(stimName);
    }
}

// ========================================================================
// STIMULUS
// ========================================================================
function stimulateBodyPart(stimName) {
    var amp = parseFloat(document.getElementById('stim-amp').value);
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ cmd: 'stimulus_preset', name: stimName, amplitude: amp }));
        activeStimulus = stimName;
        document.getElementById('stim-status').textContent = 'Active: ' + stimName;
        highlightStimulated(stimName);
    }
}

function highlightStimulated(stimName) {
    clearFlyStimHighlight();

    // Highlight all meshes whose userData.stimName matches
    for (var key in flyMeshMap) {
        var mesh = flyMeshMap[key];
        if (mesh.userData.stimName !== stimName) continue;
        if (!mesh.geometry) continue;
        var edges = new THREE.EdgesGeometry(mesh.geometry);
        var line = new THREE.LineSegments(edges,
            new THREE.LineBasicMaterial({ color: 0x34d399, linewidth: 1 })
        );
        line.position.copy(mesh.position);
        line.rotation.copy(mesh.rotation);
        line.scale.copy(mesh.scale);
        flyBodyGroup.add(line);
        flyStimHighlights.push(line);
    }

    // Odor stimuli also highlight antenna meshes
    var odorToAntenna = {
        'Odor (left antenna)': 'Tickle (left antenna)',
        'Odor (right antenna)': 'Tickle (right antenna)',
        'Odor (both antennae)': null, // both
    };
    if (odorToAntenna[stimName] !== undefined) {
        var antennaStims = odorToAntenna[stimName]
            ? [odorToAntenna[stimName]]
            : ['Tickle (left antenna)', 'Tickle (right antenna)'];
        antennaStims.forEach(function(s) {
            for (var key in flyMeshMap) {
                var mesh = flyMeshMap[key];
                if (mesh.userData.stimName !== s) continue;
                if (!mesh.geometry) continue;
                var edges = new THREE.EdgesGeometry(mesh.geometry);
                var line = new THREE.LineSegments(edges,
                    new THREE.LineBasicMaterial({ color: 0x34d399, linewidth: 1 })
                );
                line.position.copy(mesh.position);
                line.rotation.copy(mesh.rotation);
                line.scale.copy(mesh.scale);
                flyBodyGroup.add(line);
                flyStimHighlights.push(line);
            }
        });
    }

    document.querySelectorAll('.stim-zone').forEach(function(z) { z.classList.remove('stim-active'); });
}

function clearFlyStimHighlight() {
    if (!flyBodyGroup) return;
    flyStimHighlights.forEach(function(line) {
        flyBodyGroup.remove(line);
        line.geometry.dispose();
        line.material.dispose();
    });
    flyStimHighlights = [];
}

function updateFlyMotorColors(motorRates) {
    if (!motorRates) return;

    // Motor group → body name matching functions
    var motorPatterns = {
        'motor_proboscis': function(bn) { return bn === 'rostrum' || bn === 'haustellum' || bn.indexOf('labrum') === 0; },
        'motor_antenna': function(bn) { return bn.indexOf('antenna') === 0; },
        'motor_neck': function(bn) { return bn === 'head'; },
        'motor_eye': function(bn, mn) { return mn === 'head_red'; },
        'descending_left': function(bn) {
            return (bn.indexOf('_left') !== -1 && !!bn.match(/coxa|femur|tibia|tarsus|claw/)) ||
                   bn === 'wing_left' || bn === 'haltere_left';
        },
        'descending_right': function(bn) {
            return (bn.indexOf('_right') !== -1 && !!bn.match(/coxa|femur|tibia|tarsus|claw/)) ||
                   bn === 'wing_right' || bn === 'haltere_right';
        },
    };

    for (var group in motorPatterns) {
        var rate = motorRates[group] || 0;
        var intensity = Math.min(rate / 0.08, 1.0);
        var matchFn = motorPatterns[group];

        for (var key in flyMeshMap) {
            var parts = key.split('__');
            var bodyName = parts[0];
            var meshName = parts[1] || '';
            if (!matchFn(bodyName, meshName)) continue;

            var mesh = flyMeshMap[key];
            if (!mesh || !mesh.material || !mesh.material.emissive) continue;
            if (intensity > 0.01) {
                mesh.material.emissive.setRGB(
                    intensity * 0.95,
                    intensity * 0.45,
                    intensity * 0.05
                );
            } else {
                mesh.material.emissive.setRGB(0, 0, 0);
            }
        }
    }
}

// ========================================================================
// MINI STIMULUS BODY MAP (left panel)
// ========================================================================
function buildStimulusMap() {
    var container = document.getElementById('stim-body-map');
    var svgNS = 'http://www.w3.org/2000/svg';
    var svg = document.createElementNS(svgNS, 'svg');
    svg.setAttribute('viewBox', '0 0 230 195');
    svg.style.width = '100%';

    var zones = [
        ['sz-ant-l', 'Tickle (left antenna)', 'ellipse', {cx:70,cy:20,rx:28,ry:13}, 70, 30, 'L Antenna'],
        ['sz-ant-r', 'Tickle (right antenna)', 'ellipse', {cx:160,cy:20,rx:28,ry:13}, 160, 30, 'R Antenna'],
        ['sz-odor-l', 'Odor (left antenna)', 'ellipse', {cx:42,cy:42,rx:22,ry:10}, 42, 51, 'Odor L'],
        ['sz-odor-r', 'Odor (right antenna)', 'ellipse', {cx:188,cy:42,rx:22,ry:10}, 188, 51, 'Odor R'],
        ['sz-eye-l', 'Light (left eye)', 'ellipse', {cx:82,cy:60,rx:20,ry:14}, 82, 72, 'L Eye'],
        ['sz-eye-r', 'Light (right eye)', 'ellipse', {cx:148,cy:60,rx:20,ry:14}, 148, 72, 'R Eye'],
        ['sz-proboscis', 'Sugar (proboscis)', 'ellipse', {cx:115,cy:88,rx:30,ry:12}, 115, 98, 'Proboscis'],
        ['sz-body-l', 'Touch (left leg/body)', 'rect', {x:20,y:108,width:80,height:36,rx:6}, 60, 138, 'Touch L'],
        ['sz-body-r', 'Touch (right leg/body)', 'rect', {x:130,y:108,width:80,height:36,rx:6}, 170, 138, 'Touch R'],
        ['sz-odor-both', 'Odor (both antennae)', 'rect', {x:70,y:152,width:90,height:28,rx:6}, 115, 176, 'Odor Both'],
    ];

    var outline = document.createElementNS(svgNS, 'path');
    outline.setAttribute('d', 'M115,45 Q85,42 75,55 Q65,70 80,80 Q95,88 115,92 Q135,88 150,80 Q165,70 155,55 Q145,42 115,45');
    outline.setAttribute('fill', 'none');
    outline.setAttribute('stroke', '#1e293b');
    outline.setAttribute('stroke-width', '0.8');
    outline.setAttribute('opacity', '0.4');
    svg.appendChild(outline);

    zones.forEach(function(z) {
        var id = z[0], stimName = z[1], shape = z[2], attrs = z[3], lx = z[4], ly = z[5], label = z[6];
        var g = document.createElementNS(svgNS, 'g');
        g.setAttribute('class', 'stim-zone');
        g.setAttribute('id', id);
        g.addEventListener('click', function() { applyStimFromMap(stimName, id); });

        var el = document.createElementNS(svgNS, shape);
        for (var k in attrs) el.setAttribute(k, attrs[k]);
        g.appendChild(el);

        var txt = document.createElementNS(svgNS, 'text');
        txt.setAttribute('x', lx);
        txt.setAttribute('y', ly);
        txt.setAttribute('class', 'stim-zone-label');
        txt.textContent = label;
        g.appendChild(txt);

        svg.appendChild(g);
    });

    container.innerHTML = '';
    container.appendChild(svg);
}

function applyStimFromMap(stimName, zoneId) {
    var amp = parseFloat(document.getElementById('stim-amp').value);
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ cmd: 'stimulus_preset', name: stimName, amplitude: amp }));
        activeStimulus = stimName;
        document.getElementById('stim-status').textContent = 'Active: ' + stimName;

        document.querySelectorAll('.stim-zone').forEach(function(z) { z.classList.remove('stim-active'); });
        var zone = document.getElementById(zoneId);
        if (zone) zone.classList.add('stim-active');

        highlightStimulated(stimName);
    }
}

function injectCustomStimulus() {
    var amp = parseFloat(document.getElementById('stim-amp').value);
    var start = parseInt(document.getElementById('stim-start').value) || 0;
    var end = parseInt(document.getElementById('stim-end').value) || 1000;
    var indices = [];
    for (var i = start; i < end; i++) indices.push(i);
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ cmd: 'stimulus', indices: indices, amplitude: amp }));
        activeStimulus = 'Custom ' + start + '-' + end;
        document.getElementById('stim-status').textContent = 'Active: ' + activeStimulus;
    }
}

// ========================================================================
// MOTOR GRID
// ========================================================================
function buildMotorGrid(info) {
    var grid = document.getElementById('motor-grid');
    if (!info || !info.motor) return;

    var motorDefs = [
        { key: 'motor_proboscis', name: 'Proboscis', desc: 'Extension' },
        { key: 'motor_pharynx', name: 'Pharynx', desc: 'Swallowing' },
        { key: 'motor_antenna', name: 'Antennae', desc: 'Movement' },
        { key: 'motor_neck', name: 'Neck', desc: 'Head turn' },
        { key: 'motor_eye', name: 'Ocelli', desc: 'Eye adjust' },
        { key: 'descending_left', name: 'Desc. Left', desc: 'Body L' },
        { key: 'descending_right', name: 'Desc. Right', desc: 'Body R' },
        { key: 'descending_center', name: 'Desc. Center', desc: 'Bilateral' },
    ];

    grid.innerHTML = '';
    motorDefs.forEach(function(m) {
        var count = info.motor[m.key] || 0;
        if (count === 0) return;
        var card = document.createElement('div');
        card.className = 'motor-card';
        card.id = 'motor-card-' + m.key;
        card.innerHTML =
            '<div class="motor-name">' + m.name + '</div>' +
            '<div class="motor-rate" id="mr-' + m.key + '">0%</div>' +
            '<div class="motor-count">' + count + ' neurons</div>' +
            '<div class="motor-bar"><div class="motor-bar-fill" id="mb-' + m.key + '"></div></div>' +
            '<div class="motor-click-hint">click for detail</div>';
        card.addEventListener('click', (function(key, name) {
            return function() { requestMotorDetail(key, name); };
        })(m.key, m.name));
        grid.appendChild(card);
    });
}

function updateMotorGrid(motorRates) {
    if (!motorRates) return;
    for (var key in motorRates) {
        var rate = motorRates[key];
        var rateEl = document.getElementById('mr-' + key);
        var barEl = document.getElementById('mb-' + key);
        var cardEl = document.getElementById('motor-card-' + key);
        if (rateEl) rateEl.textContent = (rate * 100).toFixed(1) + '%';
        if (barEl) {
            var pct = Math.min(rate / 0.08 * 100, 100);
            barEl.style.width = pct + '%';
            if (pct > 50) barEl.style.background = '#f97316';
            else if (pct > 20) barEl.style.background = '#eab308';
            else barEl.style.background = '#3b82f6';
        }
        if (cardEl) cardEl.classList.toggle('active', rate > 0.005);
    }
}

// ========================================================================
// MOTOR DETAIL MODAL
// ========================================================================
function requestMotorDetail(groupKey, displayName) {
    if (ws && ws.readyState === 1) {
        currentMotorDetailGroup = groupKey;
        currentMotorDetailNeurons = null;
        ws.send(JSON.stringify({ cmd: 'motor_detail', group: groupKey }));
        document.getElementById('modal-group-name').textContent = displayName + ' Neurons';
    }
}

function showMotorDetail(data) {
    if (data.group !== currentMotorDetailGroup) return;

    var modal = document.getElementById('motor-modal');
    var tbody = document.getElementById('modal-neuron-tbody');
    var subtitle = document.getElementById('modal-subtitle');

    document.getElementById('modal-group-name').textContent =
        (data.group || '').replace(/_/g, ' ').replace(/\b\w/g, function(c) { return c.toUpperCase(); }) + ' Neurons';

    var neurons = data.neurons || [];
    neurons.sort(function(a, b) { return a.index - b.index; });
    currentMotorDetailNeurons = neurons;

    var activeCount = neurons.filter(function(n) { return n.active; }).length;
    subtitle.innerHTML =
        '<span class="active-count">' + activeCount + ' active</span> / ' +
        '<span class="total-count">' + neurons.length + ' total</span> neurons';

    tbody.innerHTML = '';
    neurons.forEach(function(n) {
        var tr = document.createElement('tr');
        tr.dataset.neuronIndex = n.index;
        if (n.active) tr.className = 'neuron-active';
        tr.innerHTML =
            '<td class="status-cell">' + (n.active ? 'FIRING' : 'quiet') + '</td>' +
            '<td>' + n.index + '</td>' +
            '<td>' + n.root_id + '</td>';
        tbody.appendChild(tr);
    });

    modal.classList.add('visible');
}

function updateMotorDetailLive() {
    if (!currentMotorDetailGroup || !currentMotorDetailNeurons) return;
    var now = performance.now();
    if (now - motorDetailLastUpdate < MOTOR_DETAIL_THROTTLE_MS) return;
    motorDetailLastUpdate = now;

    var activeSet = new Set(lastActiveIndices);
    var tbody = document.getElementById('modal-neuron-tbody');
    var rows = tbody.children;
    var activeCount = 0;

    for (var i = 0; i < currentMotorDetailNeurons.length && i < rows.length; i++) {
        var n = currentMotorDetailNeurons[i];
        var wasActive = n.active;
        n.active = activeSet.has(n.index);
        if (n.active) activeCount++;
        if (n.active !== wasActive) {
            var tr = rows[i];
            tr.className = n.active ? 'neuron-active' : '';
            tr.children[0].textContent = n.active ? 'FIRING' : 'quiet';
        }
    }

    document.getElementById('modal-subtitle').innerHTML =
        '<span class="active-count">' + activeCount + ' active</span> / ' +
        '<span class="total-count">' + currentMotorDetailNeurons.length + ' total</span> neurons';
}

function closeMotorModal() {
    document.getElementById('motor-modal').classList.remove('visible');
    currentMotorDetailGroup = null;
    currentMotorDetailNeurons = null;
}

document.getElementById('motor-modal').addEventListener('click', function(e) {
    if (e.target === this) closeMotorModal();
});
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') closeMotorModal();
});

// ========================================================================
// WEBSOCKET
// ========================================================================
function connect() {
    ws = new WebSocket(window.WS_BASE_URL + '/ws');

    ws.onopen = function() {
        document.getElementById('status-dot').className = 'status-dot connected';
        document.getElementById('status-text').textContent = 'Connected (paused)';
    };

    ws.onclose = function() {
        document.getElementById('status-dot').className = 'status-dot disconnected';
        document.getElementById('status-text').textContent = 'Disconnected';
        running = false;
        setTimeout(connect, 2000);
    };

    ws.onmessage = function(ev) {
        var msg = JSON.parse(ev.data);
        if (msg.type === 'metrics') {
            updateMetrics(msg);
        } else if (msg.type === 'init') {
            bodyInfo = msg.body_info;
            document.getElementById('m-neurons').textContent = msg.n_neurons.toLocaleString();
            document.getElementById('m-synapses').textContent = msg.n_synapses.toLocaleString();
            buildMotorGrid(bodyInfo);
            sendParam('send_active_indices', document.getElementById('tog-3d').checked ? 1 : 0);
            sendParam('send_motor_rates', document.getElementById('tog-motor').checked ? 1 : 0);
        } else if (msg.type === 'state') {
            running = msg.running;
            updateRunState();
        } else if (msg.type === 'motor_detail') {
            showMotorDetail(msg);
        }
    };
}

function sendCmd(cmd) {
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ cmd: cmd }));
        if (cmd === 'start') { running = true; updateRunState(); }
        if (cmd === 'pause') { running = false; updateRunState(); }
    }
}

function sendParam(key, value) {
    if (ws && ws.readyState === 1) {
        ws.send(JSON.stringify({ cmd: 'set_param', key: key, value: parseFloat(value) }));
    }
}

function clearStimulus() {
    sendCmd('clear_stimulus');
    activeStimulus = null;
    document.getElementById('stim-status').textContent = '';
    clearFlyStimHighlight();
    document.querySelectorAll('.stim-zone').forEach(function(z) { z.classList.remove('stim-active'); });
}

function updateRunState() {
    var dot = document.getElementById('status-dot');
    var txt = document.getElementById('status-text');
    var btnPlay = document.getElementById('btn-play');
    var btnPause = document.getElementById('btn-pause');
    if (running) {
        dot.className = 'status-dot running';
        txt.textContent = 'Running';
        btnPlay.classList.add('active');
        btnPause.classList.remove('active');
    } else {
        dot.className = 'status-dot paused';
        txt.textContent = 'Paused';
        btnPlay.classList.remove('active');
        btnPause.classList.add('active');
    }
}

// ========================================================================
// METRICS
// ========================================================================
function updateMetrics(m) {
    document.getElementById('m-step').textContent = m.step.toLocaleString();
    document.getElementById('m-rate').textContent = (m.firing_rate * 100).toFixed(2) + '%';
    document.getElementById('m-spikes').textContent = m.spike_count.toLocaleString();
    document.getElementById('m-voltage').textContent = m.mean_voltage.toFixed(3);
    document.getElementById('m-sps').textContent = Math.round(m.steps_per_sec).toLocaleString();

    var realtime = m.steps_per_sec / 1000;
    document.getElementById('m-realtime').textContent = realtime.toFixed(1) + 'x';

    // Motor colors and grid
    lastMotorRates = m.motor_rates;
    updateFlyMotorColors(m.motor_rates);
    updateMotorGrid(m.motor_rates);
    updateMotorDetailLive();

    // Brain activity
    if (m.active_indices) {
        lastActiveIndices = m.active_indices;
        updateBrainActivity(m.active_indices);
    }
}

// ========================================================================
// SPEED SLIDER
// ========================================================================
function updateSpeedSlider(el) {
    var v = parseFloat(el.value);
    speedMultiplier = Math.pow(10, v / 10);
    document.getElementById('speed-val').textContent = speedMultiplier.toFixed(1) + 'x';

    // Update simulation batch_size
    var newBatch = Math.max(1, Math.min(500, Math.round(BASE_BATCH * speedMultiplier)));
    sendParam('batch_size', newBatch);
}

function updateSlider(el, spanId) {
    var span = document.getElementById(spanId);
    span.textContent = parseFloat(el.value).toFixed(el.step.includes('.') ? 2 : 0);
}

// ========================================================================
// INIT
// ========================================================================
window.addEventListener('load', function() {
    buildStimulusMap();
    initScene();
    connect();
});

window.addEventListener('resize', onResize);
</script>
</body>
</html>
